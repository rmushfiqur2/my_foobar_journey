from​ ​copy​ ​import​ ​copy,​ ​deepcopy
from​ ​collections​ ​import​ ​defaultdict​ ​as​ ​dd

update_goal_t_v_f​ ​=​ ​{
​ ​​ ​​ ​​ ​'w':​ ​'a',
​ ​​ ​​ ​​ ​'a':​ ​'b',
​ ​​ ​​ ​​ ​'b':​ ​'c',
​ ​​ ​​ ​​ ​'c':​ ​'c',​ ​​ ​#​ ​final​ ​state
​ ​​ ​​ ​​ ​'d':​ ​'d'​ ​​ ​#​ ​final​ ​state
}
update_goal_t_v_t​ ​=​ ​{
​ ​​ ​​ ​​ ​'w':​ ​'d',
​ ​​ ​​ ​​ ​'a':​ ​'d',
​ ​​ ​​ ​​ ​'b':​ ​'d',
​ ​​ ​​ ​​ ​'c':​ ​'c',​ ​​ ​#​ ​final​ ​state
​ ​​ ​​ ​​ ​'d':​ ​'d'​ ​​ ​#​ ​final​ ​state
}
demand_goal_t​ ​=​ ​{
​ ​​ ​​ ​​ ​'c':​ ​1,
​ ​​ ​​ ​​ ​'d':​ ​0
}
update_goal_f_v_f​ ​=​ ​{
​ ​​ ​​ ​​ ​'w':​ ​'a',
​ ​​ ​​ ​​ ​'a':​ ​'b',
​ ​​ ​​ ​​ ​'b':​ ​'c',
​ ​​ ​​ ​​ ​'f':​ ​'e',
​ ​​ ​​ ​​ ​'e':​ ​'d',
​ ​​ ​​ ​​ ​'c':​ ​'c',​ ​​ ​#​ ​final​ ​state
​ ​​ ​​ ​​ ​'d':​ ​'d',​ ​​ ​#​ ​final​ ​state
​ ​​ ​​ ​​ ​'s':​ ​'s'​ ​​ ​#​ ​sleep​ ​stage
}
update_goal_f_v_t​ ​=​ ​{
​ ​​ ​​ ​​ ​'w':​ ​'f',
​ ​​ ​​ ​​ ​'a':​ ​'e',
​ ​​ ​​ ​​ ​'b':​ ​'d',
​ ​​ ​​ ​​ ​'f':​ ​'s',
​ ​​ ​​ ​​ ​'e':​ ​'s',
​ ​​ ​​ ​​ ​'c':​ ​'c',​ ​​ ​#​ ​final​ ​state
​ ​​ ​​ ​​ ​'d':​ ​'d',​ ​​ ​#​ ​final​ ​state
​ ​​ ​​ ​​ ​'s':​ ​'s'​ ​​ ​#​ ​sleep​ ​stage
}
demand_goal_f​ ​=​ ​{
​ ​​ ​​ ​​ ​'c':​ ​0,
​ ​​ ​​ ​​ ​'d':​ ​1
}
ly,​ ​lx​ ​=​ ​0,​ ​0


class​ ​customState:
​ ​​ ​​ ​​ ​def​ ​__init__(self,​ ​goal):
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​self.goal​ ​=​ ​goal
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​self.state​ ​=​ ​'w'

​ ​​ ​​ ​​ ​def​ ​update(self,​ ​value):
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​global​ ​update_goal_t_v_f,​ ​update_goal_t_v_t,​ ​update_goal_f_v_f,​ ​update_goal_f_v_t
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​self.goal:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​value:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​self.state​ ​=​ ​update_goal_t_v_t.get(self.state,​ ​'default')
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​else:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​self.state​ ​=​ ​update_goal_t_v_f.get(self.state,​ ​'default')
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​else:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​value:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​self.state​ ​=​ ​update_goal_f_v_t.get(self.state,​ ​'default')
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​else:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​self.state​ ​=​ ​update_goal_f_v_f.get(self.state,​ ​'default')

​ ​​ ​​ ​​ ​def​ ​demand(self):
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​global​ ​demand_goal_t,​ ​demand_goal_f
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​self.goal:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​return​ ​demand_goal_t.get(self.state,​ ​-1)
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​else:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​return​ ​demand_goal_f.get(self.state,​ ​-1)


def​ ​soln_one_row_eff(g,​ ​valid_row0):
​ ​​ ​​ ​​ ​global​ ​ly,​ ​lx
​ ​​ ​​ ​​ ​ly​ ​=​ ​len(g)
​ ​​ ​​ ​​ ​s​ ​=​ ​[]​ ​​ ​#​ ​customState​ ​2D​ ​array
​ ​​ ​​ ​​ ​for​ ​gx​ ​in​ ​g:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​lx​ ​=​ ​len(gx)
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​sx​ ​=​ ​[]
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​for​ ​gxy​ ​in​ ​gx:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​sx.append(customState(gxy))
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​s.append(sx)
​ ​​ ​​ ​​ ​count​ ​=​ ​0
​ ​​ ​​ ​​ ​common_row_0​ ​=​ ​dd(lambda:​ ​dd(lambda:​ ​0))​ ​​ ​#​ ​it​ ​requires​ ​inner​ ​dictionary​ ​(row0​ ​-​ ​>​ ​row1​ ​->​ ​count)​ ​\
​ ​​ ​​ ​​ ​#​ ​necessary​ ​for​ ​other​ ​than​ ​first​ ​row​ ​(valid_row0!=None)
​ ​​ ​​ ​​ ​common_row_1​ ​=​ ​dd(lambda:​ ​0)​ ​​ ​#​ ​count​ ​only​ ​(row1​ ​->​ ​count)​ ​#​ ​necessary​ ​only​ ​for​ ​first​ ​row​ ​(valid_row0==None)
​ ​​ ​​ ​​ ​def​ ​insert_common_combination(common_val_0,​ ​common_val_1):
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​common_val_1​ ​in​ ​common_row_0[common_val_0].keys():
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​common_row_0[common_val_0][common_val_1]​ ​+=​ ​1
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​else:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​common_row_0[common_val_0][common_val_1]​ ​=​ ​1
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​common_row_1[common_val_1]​ ​+=​ ​1

​ ​​ ​​ ​​ ​prev_state​ ​=​ ​[]
​ ​​ ​​ ​​ ​for​ ​i​ ​in​ ​range(ly​ ​+​ ​1):
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​prev​ ​=​ ​[]
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​for​ ​j​ ​in​ ​range(lx​ ​+​ ​1):
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​prev.append('u')​ ​​ ​#​ ​unknown
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​prev_state.append(prev)

​ ​​ ​​ ​​ ​stack​ ​=​ ​[[s,​ ​0,​ ​0,​ ​prev_state,​ ​0,​ ​0]]

​ ​​ ​​ ​​ ​while​ ​len(stack):
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​initial​ ​=​ ​stack.pop()
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​s,​ ​currentI,​ ​currentJ,​ ​prev_state,​ ​common_val_0,​ ​common_val_1​ ​=​ ​initial[0],​ ​initial[1],​ ​initial[2],​ ​initial[3],​ ​\
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​initial[4],​ ​initial[5]
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​bad​ ​=​ ​False
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​for​ ​i​ ​in​ ​range(currentI,​ ​ly​ ​+​ ​1):
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​escape​ ​=​ ​False
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​i​ ​==​ ​1​ ​and​ ​valid_row0!=None​ ​and​ ​common_val_0​ ​not​ ​in​ ​valid_row0.keys():
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​j​ ​=​ ​lx​ ​+​ ​1
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​escape​ ​=​ ​True

​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​for​ ​j​ ​in​ ​range(currentJ,​ ​lx​ ​+​ ​1):
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​prev_state[i][j]​ ​!=​ ​'u':​ ​​ ​#​ ​already​ ​known
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​i​ ​==​ ​0:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​common_val_0​ ​=​ ​common_val_0​ ​*​ ​2​ ​+​ ​(prev_state[i][j]​ ​==​ ​'t')
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​else:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​common_val_1​ ​=​ ​common_val_1​ ​*​ ​2​ ​+​ ​(prev_state[i][j]​ ​==​ ​'t')
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​continue
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​points​ ​=​ ​[]
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​demands​ ​=​ ​[]
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​i​ ​>​ ​0​ ​and​ ​j​ ​<​ ​lx:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​points.append(s[i​ ​-​ ​1][j])
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​demands.append(s[i​ ​-​ ​1][j].demand())
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​i​ ​>​ ​0​ ​and​ ​j​ ​>​ ​0:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​points.append(s[i​ ​-​ ​1][j​ ​-​ ​1])
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​demands.append(s[i​ ​-​ ​1][j​ ​-​ ​1].demand())
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​i​ ​<​ ​ly​ ​and​ ​j​ ​>​ ​0:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​points.append(s[i][j​ ​-​ ​1])
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​demands.append(s[i][j​ ​-​ ​1].demand())
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​i​ ​<​ ​ly​ ​and​ ​j​ ​<​ ​lx:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​points.append(s[i][j])
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​demands.append(s[i][j].demand())

​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​One​ ​=​ ​any(demand​ ​==​ ​1​ ​for​ ​demand​ ​in​ ​demands)
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​Zero​ ​=​ ​any(demand​ ​==​ ​0​ ​for​ ​demand​ ​in​ ​demands)

​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​One​ ​and​ ​Zero:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​escape​ ​=​ ​True
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​break
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​elif​ ​One:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​for​ ​point​ ​in​ ​points:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​point.update(True)
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​prev_state[i][j]​ ​=​ ​'t'​ ​​ ​#​ ​True
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​i​ ​==​ ​0:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​common_val_0​ ​=​ ​common_val_0​ ​*​ ​2​ ​+​ ​1
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​else:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​common_val_1​ ​=​ ​common_val_1​ ​*​ ​2​ ​+​ ​1
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​elif​ ​Zero:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​for​ ​point​ ​in​ ​points:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​point.update(False)
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​prev_state[i][j]​ ​=​ ​'f'​ ​​ ​#​ ​False
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​i​ ​==​ ​0:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​common_val_0​ ​=​ ​common_val_0​ ​*​ ​2
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​else:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​common_val_1​ ​=​ ​common_val_1​ ​*​ ​2
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​else:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​new_s​ ​=​ ​deepcopy(s)
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​new_prev_state​ ​=​ ​deepcopy(prev_state)
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​new_common_val_0​ ​=​ ​common_val_0
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​new_common_val_1​ ​=​ ​common_val_1

​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​for​ ​point​ ​in​ ​points:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​point.update(True)
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​prev_state[i][j]​ ​=​ ​'t'
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​i​ ​==​ ​0:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​common_val_0​ ​=​ ​common_val_0​ ​*​ ​2​ ​+​ ​1
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​else:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​common_val_1​ ​=​ ​common_val_1​ ​*​ ​2​ ​+​ ​1

​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​new_prev_state[i][j]​ ​=​ ​'f'
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​i​ ​==​ ​0:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​new_common_val_0​ ​=​ ​new_common_val_0​ ​*​ ​2
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​else:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​new_common_val_1​ ​=​ ​new_common_val_1​ ​*​ ​2
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​i​ ​>​ ​0​ ​and​ ​j​ ​<​ ​lx:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​new_s[i​ ​-​ ​1][j].update(False)
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​i​ ​>​ ​0​ ​and​ ​j​ ​>​ ​0:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​new_s[i​ ​-​ ​1][j​ ​-​ ​1].update(False)
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​i​ ​<​ ​ly​ ​and​ ​j​ ​>​ ​0:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​new_s[i][j​ ​-​ ​1].update(False)
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​i​ ​<​ ​ly​ ​and​ ​j​ ​<​ ​lx:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​new_s[i][j].update(False)

​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​j​ ​==​ ​lx​ ​and​ ​i​ ​==​ ​ly:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​count​ ​+=​ ​1
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​insert_common_combination(new_common_val_0,​ ​new_common_val_1)
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​elif​ ​j​ ​<​ ​lx​ ​or​ ​i​ ​<​ ​ly:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​stack.append([new_s,​ ​i,​ ​j​ ​+​ ​1,​ ​new_prev_state,​ ​new_common_val_0,​ ​new_common_val_1])
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​currentJ​ ​=​ ​0
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​escape:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​bad​ ​=​ ​True
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​break
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​not​ ​bad:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​count​ ​+=​ ​1
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​insert_common_combination(common_val_0,​ ​common_val_1)
​ ​​ ​​ ​​ ​return​ ​common_row_0,​ ​common_row_1

def​ ​transpose_arr(arr):​ ​#​ ​if​ ​arr​ ​is​ ​fat,​ ​transposes​ ​it​ ​(to​ ​tall​ ​matrix)
​ ​​ ​​ ​​ ​h,w​ ​=​ ​len(arr),​ ​len(arr[0])
​ ​​ ​​ ​​ ​if​ ​h​ ​>=​ ​w:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​return​ ​arr
​ ​​ ​​ ​​ ​arr2​ ​=​ ​[]
​ ​​ ​​ ​​ ​for​ ​i​ ​in​ ​range(w):
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​arr2.append([])
​ ​​ ​​ ​​ ​for​ ​a​ ​in​ ​arr:
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​for​ ​i,​ ​v​ ​in​ ​enumerate(a):
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​arr2[i].append(v)
​ ​​ ​​ ​​ ​return​ ​arr2

def​ ​solution(arr):
​ ​​ ​​ ​​ ​arr​ ​=​ ​transpose_arr(arr)
​ ​​ ​​ ​​ ​common_row_0,​ ​common_row_1​ ​=​ ​soln_one_row_eff([arr[0]],None)

​ ​​ ​​ ​​ ​num​ ​=​ ​0
​ ​​ ​​ ​​ ​for​ ​i​ ​in​ ​range(1,​ ​len(arr)):
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​common_row_0,​ ​_​ ​=​ ​soln_one_row_eff([arr[i]],​ ​common_row_1)
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​common_row_1_next​ ​=​ ​dd(lambda:0)
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​num​ ​=​ ​0
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​for​ ​k​ ​in​ ​common_row_1.keys():
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​if​ ​k​ ​in​ ​common_row_0.keys():
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​for​ ​kk​ ​in​ ​common_row_0[k].keys():
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​nn​ ​=​ ​common_row_1[k]​ ​*​ ​common_row_0[k][kk]
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​common_row_1_next[kk]​ ​+=​ ​nn
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​num​ ​+=​ ​nn
​ ​​ ​​ ​​ ​​ ​​ ​​ ​​ ​common_row_1​ ​=​ ​common_row_1_next
​ ​​ ​​ ​​ ​return​ ​num